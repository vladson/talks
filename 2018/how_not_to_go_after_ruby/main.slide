How not to Ruby on Go
01 October 2018

Vladislav Bogomolov
Backend Developer, Gett RnD
bogomolov@gett.com
https://engineering.gett.com/
http://github.com/vladson
@vladson4ik

: 10 лет знаком с руби, 8 лет продакшн опыта. Backend. 
: Было желание строго-типизированных языков

* Gett
.background images/background.png

Monolith drawbacks:
- scalability
- support
- entanglement => new features development

.video images/piglets.webm video/mp4 _ 300
: Проблемы с производительностью, и главное с поддержкой и развитием новых фич.

* Gett SOA
.background images/background.png

*Pros:*
- allows Continuous Delivery / Deployment - almost the only way to go
- support R&D growth 
- ability to Scale / Improve Availability of specific parts independently
- allow Multiple Technology Stack work side by Side

*Cons:*
- development & operational overhead
- network overhead
- more points of failure

: на SOA перешли в 2014, Node, ROR, Go fixed 2016

* Gett SOA
.background images/background.png

- services are built around business process
- SRP single responsibility principle
size guidelines:
- 200 < LOC < 5000
- easy to rewrite in a month

*State:*
- first service on Node.js in 2014
- several other on ROR
- now more than 70

* Gett Go
.background images/background.png
2015 First service on Go — locations service.

.image images/gonode.png _ 700

Late 2016 - Golang as a language of choice

* Ruby
.background images/background.png  

- interpretable
- object oriented
- dynamically typed
- dsl-oriented

.image images/redTrain.jpg 300 _

* Golang
.background images/background.png

- compilable
- static
- structured
- strong typed
- embedded concurrency support

 go YourAwesomeAsyncFunc(c *Context, payload map[string][string] )
 
.image images/gopher_sneaking.png _ 300

* Questions and decisions to make
.background images/background.png

- Should I use any framework?
- How to structure your app
- How to split responsibilities?
- What ORM should I use if any?
- How to handle Exceptions?
- How to deal with testing?
  
* What issues did we encountered?

- Strange to start thinking in Go paradigm
- Bad code leads to worse code
- Codebase becomes incompatible with libraries
- Familiar approach result in messy code
: functions not classes, packages not 
: Написание кода на Go непонятно как. 
: Чем больше велосипедов -  тем больше велосипедов
: 

* Frameworks
.background images/background.png

* Frameworks
.background images/background.png

Beego, Martiny, Revel ...
 
Why not?
 - possibly wrong conceptions
 - possible problems with structure
 - less understanding of the Go way  

* How to split responsibilities?

.background images/background.png

.image images/abstractionsEverywhere.jpg _ 600

* How not to split responsibilities?

.background images/background.png

.code code/package.go  /START OMIT/,/END OMIT/

- keep track of packages
- Your code should reside in corresponding packages

* How to structure your app

.background images/background.png
.image images/house-of-cards.jpg 500 _

* How to structure your app

.background images/background.png

- MVC with corresponding layered structure is not usefull for Go
- DDD rules

- GoWay fest 2018 - Kat Zién: [[https://github.com/katzien/talks/blob/master/how-do-you-structure-your-go-apps/gowayfest2.0-2018-09-28/slides.pdf][How do you structure your Go apps?]]

* Database
.background images/background.png

* What ORM should I use if any?

.background images/background.png
 
How it's done in Ruby?
 
 class User < Activerecord::Base
 ...
 User.find
 User.save
 ...

- lots of implicit stuff
- lots of abstractions
- mix of responsibility

* Do you need them in Go?

.background images/background.png

In many cases you need no ORM, just _"database/sql"_ package

.code code/plain_sql.go  /START OMIT/,/END OMIT/

* Existing ORMs

.background images/background.png
- [[https://github.com/jinzhu/gorm][Gorm]]
Activerecord like ORM,
problems:
- mix of responsibility
- unpredictable behaviour
- usage of _interface{}_ values
- no migrations

- [[https://github.com/go-reform/reform][Reform]] 
Code-generation based approach, thus provides usable interface. Data Mapper pattern. 

problems:
- mostly no problems
- unless you have some
- no migrations 


* Migrations

.background images/background.png
- No common techniques

- In Gett we use Swan, based on [[https://bitbucket.org/liamstask/goose] Goose]

1. File based migrations
2. Dangerous migrations warning
3. Support concurrent indices 

 BEGIN;
 CREATE INDEX CONCURRENTLY idx ON  table_name (field0, field1);
 COMMIT;
 
* Exceptions

.background images/background.png
 
* Exceptions in Ruby

.background images/background.png

.image images/rubyExceptions.png _ 300

 begin do
   ...
 rescue ServiceFailError => e
   ...
 end
 
* Mistakes for errors in Go

.background images/background.png

- use _defer_— _Panic_ — _recover_ as exception flow control

.code code/panic.go  /START OMIT/,/END OMIT/

- create a set of custom errors.

* Better error handling approach

.background images/background.png

Always use [[https://github.com/pkg/errors][pkg/errors]]

.code code/errors.go /START OMIT/,/END OMIT/

- preserves the initial cause
- easy to follow through code 

* Testing

.background images/background.png

* Testing in Ruby
.background images/background.png

no brainer — *rspec* or *minitest*

Should we end up with something like *rspec*?

* Testing in Go
.background images/background.png

[[https://golang.org/pkg/testing/][pkg/testing]]
- golang native 
- benchmarks
- every test is runnable

 // test 
 func TestTimeConsuming(t *testing.T) { ...
 
 // benchmark
 func BenchmarkHello(b *testing.B) {
 
[[https://github.com/stretchr/testify][testify]]


[[https://onsi.github.io/ginkgo/][Ginkgo]]
pros: BDD
cons: 
- not in a _Go way_
- only suites accept (*testing.T)

* Summary
.background images/background.png

* Summary
.background images/background.png

- Explicit is better than implicit
- Keep things simple
- Use existing solutions and be compatible with standard library
 
